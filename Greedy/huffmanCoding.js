class HuffmanNode {
    constructor(data, char) {
        this.data = data;
        this.char = char;
        this.left = null;
        this.right = null;
    }

    print(root, s) {
        // base case; if the left and right are null
        // then its a leaf node and we print
        // the code s generated by traversing the tree.
        
        if (root.left === null && root.right === null && this.isLetter(root.char)) {
            console.log(root.char, " : ", s);
            return;
        }
        // if we go to left then add "0" to the code.
        // if we go to the right add"1" to the code.
 
        // recursive calls for left and
        // right sub-tree of the generated tree.
        this.print(root.left, s + "0");
        this.print(root.right, s + "1");
    }

    isLetter(char) {
        if (char >= 'a' && char <= 'z') {
            return true;
        }
        else{
        return false;
        }
    }
}

class PrioriyQueue {
    constructor() {
        this.heapArray = [];
    }
    add(hn) {
        this.heapArray.push(hn);
    }
    buildHeap() {
        let n = this.heapArray.length;
        let index = Math.floor(n / 2) - 1;
        for (let i = index; i >= 0; i--) {
            this.heapify(n, i);
        }
    }

    heapify(n, i) {
        let smallest = i;
        let left = 2 * i + 1;
        let right = 2 * i + 2;
        if (left < n && this.heapArray[left].data < this.heapArray[smallest].data) {
            smallest = left;
        }
        if (right < n && this.heapArray[right].data < this.heapArray[smallest].data) {
            smallest = right;
        }
        if (i !== smallest) {
            [this.heapArray[i], this.heapArray[smallest]] = [this.heapArray[smallest], this.heapArray[i]];
            this.heapify(n, smallest);
        }
    }

    showPriorityQueue() {   
        console.log(this.heapArray);
    }

    size() {
        return this.heapArray.length;
    }
}
const mainFunction = () => {
    let n = 6;
    let charArray = ['a', 'b', 'c', 'd', 'e', 'f'];
    let charFrequency = [5, 9, 12, 13, 16, 45];
    // let charFrequency = [12, 2, 7, 13, 14, 85];
    // creating a priority queue q.
    // makes a min-priority queue(min-heap)

    const PQ = new PrioriyQueue();
    for (let i = 0; i < n; i++) {
        let data = charFrequency[i];
        let char = charArray[i];
        const hn = new HuffmanNode(data, char);
        PQ.add(hn);
    }
    PQ.buildHeap();
    PQ.showPriorityQueue();
    // Here we will extract the two minimum value
    // from the heap each time until
    // its size reduces to 1, extract until
    // all the nodes are extracted.
    let z = new HuffmanNode();
    let root= new HuffmanNode();
    while (PQ.size() > 1) {
        // Extracts the first min
        let x = PQ.heapArray.shift();
        // Extracts the second min
        let y = PQ.heapArray.shift();
        // new node z which is equal
        z = new HuffmanNode();
        // to the sum of the frequency of the two nodes
        // assigning values to the f node.
        z.data = x.data + y.data;
        z.char = '-';
        // first extracted node as left child.
        z.left = x;
        // second extracted node as the right child.
        z.right = y;
        root = z;
        // add this node to the priority-queue.
        PQ.add(z);
        PQ.buildHeap();
       //PQ.showPriorityQueue();
    }
    z.print(root, "");
};

mainFunction();

exports = {
    mainFunction,
};